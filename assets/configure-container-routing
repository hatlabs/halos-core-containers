#!/bin/bash
# configure-container-routing - Configure routing for a single container app
#
# This script is called by container services in their ExecStartPre to
# generate Traefik routing configuration before the container starts.
#
# Usage: configure-container-routing <app_id>
#
# This script reads /etc/halos/routing.d/<app_id>.yml and generates:
# 1. Docker-compose override file in /run/halos/routing-labels/
# 2. Per-app ForwardAuth middleware in /etc/halos/traefik-dynamic.d/ (if needed)
#
# Provided by halos-traefik-container. Other proxy packages (caddy, nginx)
# would provide their own implementation of this command.

set -e

# Directories can be overridden via environment variables for testing
ROUTING_DIR="${ROUTING_DIR:-/etc/halos/routing.d}"
OUTPUT_DIR="${OUTPUT_DIR:-/run/halos/routing-labels}"
MIDDLEWARE_DIR="${MIDDLEWARE_DIR:-/etc/halos/traefik-dynamic.d}"

# Get HALOS_DOMAIN from environment or derive from hostname
if [ -z "${HALOS_DOMAIN}" ]; then
    HOSTNAME="$(hostname -s)"
    HALOS_DOMAIN="${HOSTNAME}.local"
fi

log() {
    echo "[configure-container-routing] $1"
}

# Parse YAML value - simple grep-based parser for our known format
# Usage: yaml_get "key" < file.yml
yaml_get() {
    local key="$1"
    grep "^${key}:" | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//'
}

# Parse nested YAML value
# Usage: yaml_get_nested "parent" "child" < file.yml
yaml_get_nested() {
    local parent="$1"
    local child="$2"
    # Strip both double quotes ("") and single quotes ('') from YAML values
    sed -n "/^${parent}:/,/^[a-z]/p" | grep "^  ${child}:" | sed "s/^  ${child}:[[:space:]]*//" | sed "s/^[\"']//; s/[\"']$//"
}

# Parse deeply nested YAML value (3 levels)
# Usage: yaml_get_deep "parent" "child" "grandchild" < file.yml
yaml_get_deep() {
    local parent="$1"
    local child="$2"
    local grandchild="$3"
    sed -n "/^${parent}:/,/^[a-z]/p" | sed -n "/^  ${child}:/,/^  [a-z]/p" | grep "^    ${grandchild}:" | sed "s/^    ${grandchild}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//'
}

# Check if a routing file has custom forward auth headers
has_custom_headers() {
    local file="$1"
    # Check for headers under auth.forward_auth.headers
    grep -q "forward_auth:" "$file" 2>/dev/null && \
        grep -q "headers:" "$file" 2>/dev/null && \
        grep -qE "^[[:space:]]{6,}[A-Za-z]" "$file" 2>/dev/null
}

# Extract custom headers as key=value pairs
# Returns lines like: Remote-User=X-WEBAUTH-USER
get_custom_headers() {
    local file="$1"
    # Extract lines under headers: that look like "key: value"
    sed -n '/^auth:/,/^[a-z]/p' "$file" | \
        sed -n '/forward_auth:/,/^  [a-z]/p' | \
        sed -n '/headers:/,/^    [a-z]/p' | \
        grep -E "^[[:space:]]{6,}[A-Za-z]" | \
        sed 's/^[[:space:]]*//' | \
        sed 's/:[[:space:]]*/=/'
}

# Generate per-app ForwardAuth middleware YAML
generate_middleware() {
    local app_id="$1"
    local routing_file="$2"
    local middleware_file="${MIDDLEWARE_DIR}/authelia-${app_id}.yml"

    log "Generating middleware for ${app_id}"

    # Get custom headers
    local headers=""
    while IFS='=' read -r authelia_header app_header; do
        if [ -n "${authelia_header}" ]; then
            headers="${headers}
          - ${authelia_header}"
        fi
    done < <(get_custom_headers "$routing_file")

    cat > "${middleware_file}" << EOF
# Per-app ForwardAuth middleware for ${app_id}
# Auto-generated by configure-container-routing
# Custom header mappings from routing.yml

http:
  middlewares:
    authelia-${app_id}:
      forwardAuth:
        address: "http://authelia:9091/api/authz/forward-auth"
        trustForwardHeader: true
        authResponseHeaders:${headers}
EOF

    chmod 644 "${middleware_file}"
    log "Created middleware: ${middleware_file}"
}

# Generate docker-compose override with Traefik labels
generate_override() {
    local routing_file="$1"

    # Parse routing.yml
    local app_id
    local service_name
    local subdomain
    local port
    local backend_type
    local auth_mode

    app_id=$(yaml_get "app_id" < "$routing_file")
    service_name=$(yaml_get_deep "routing" "backend" "service" < "$routing_file")
    port=$(yaml_get_deep "routing" "backend" "port" < "$routing_file")
    backend_type=$(yaml_get_deep "routing" "backend" "type" < "$routing_file")
    backend_scheme=$(yaml_get_deep "routing" "backend" "scheme" < "$routing_file")
    auth_mode=$(yaml_get_nested "auth" "mode" < "$routing_file")

    # Handle subdomain specially: empty string ("") is valid (means root domain)
    # Only default to app_id if subdomain key is not present at all
    if grep -q "^  subdomain:" "$routing_file"; then
        subdomain=$(yaml_get_nested "routing" "subdomain" < "$routing_file")
    else
        subdomain="${app_id}"
    fi

    # Validate required fields
    if [ -z "${app_id}" ]; then
        log "ERROR: Missing app_id in ${routing_file}"
        return 1
    fi

    if [ -z "${service_name}" ]; then
        log "ERROR: Missing routing.backend.service in ${routing_file}"
        return 1
    fi

    if [ -z "${port}" ]; then
        log "ERROR: Missing routing.backend.port in ${routing_file}"
        return 1
    fi

    # Default values for optional fields
    [ -z "${backend_type}" ] && backend_type="container"
    [ -z "${auth_mode}" ] && auth_mode="forward_auth"

    log "Processing ${app_id}: subdomain=${subdomain}, port=${port}, auth=${auth_mode}"

    # Build host rule
    local host_rule
    if [ -z "${subdomain}" ]; then
        # Empty subdomain = root domain
        host_rule="Host(\`\${HALOS_DOMAIN}\`)"
    else
        host_rule="Host(\`${subdomain}.\${HALOS_DOMAIN}\`)"
    fi

    # Determine middleware
    local middleware_label=""
    if [ "${auth_mode}" = "forward_auth" ]; then
        if has_custom_headers "$routing_file"; then
            # Generate per-app middleware
            generate_middleware "${app_id}" "$routing_file"
            middleware_label="      traefik.http.routers.${app_id}-secure.middlewares: \"authelia-${app_id}@file\""
        else
            # Use default Authelia middleware
            middleware_label="      traefik.http.routers.${app_id}-secure.middlewares: \"authelia@file\""
        fi
    fi
    # For OIDC and none auth modes, no middleware label is added

    # Determine backend configuration
    # Use scheme from routing.yml if specified, default to http
    local scheme="${backend_scheme:-http}"
    local backend_label
    local scheme_label=""
    local transport_label=""
    if [ "${backend_type}" = "host" ]; then
        backend_label="      traefik.http.services.${app_id}.loadbalancer.server.url: \"${scheme}://host.docker.internal:${port}\""
    else
        backend_label="      traefik.http.services.${app_id}.loadbalancer.server.port: \"${port}\""
        # Add scheme and transport labels for HTTPS backends
        # Traefik defaults to HTTP, and HTTPS backends typically use self-signed certs
        if [ "${scheme}" = "https" ]; then
            scheme_label="      traefik.http.services.${app_id}.loadbalancer.server.scheme: \"https\""
            transport_label="      traefik.http.services.${app_id}.loadbalancer.serversTransport: \"insecure@file\""
        fi
    fi

    # Generate override file with separate HTTP and HTTPS routers
    local override_file="${OUTPUT_DIR}/${app_id}.yml"

    cat > "${override_file}" << EOF
# Docker-compose override with Traefik labels for ${app_id}
# Auto-generated by configure-container-routing
# Source: ${routing_file}

services:
  ${service_name}:
    labels:
      traefik.enable: "true"
      # HTTP router - redirects to HTTPS
      traefik.http.routers.${app_id}.rule: "${host_rule}"
      traefik.http.routers.${app_id}.entrypoints: "web"
      traefik.http.routers.${app_id}.middlewares: "redirect-to-https@file"
      # HTTPS router (websecure entrypoint with TLS)
      traefik.http.routers.${app_id}-secure.rule: "${host_rule}"
      traefik.http.routers.${app_id}-secure.entrypoints: "websecure"
      traefik.http.routers.${app_id}-secure.tls: "true"
${middleware_label}
      # Backend service
${backend_label}
${scheme_label}
${transport_label}
      halos.subdomain: "${subdomain}"
EOF

    chmod 644 "${override_file}"
    log "Created override: ${override_file}"
}

# Main
main() {
    local app_id="$1"

    if [ -z "${app_id}" ]; then
        echo "Usage: configure-container-routing <app_id>" >&2
        exit 1
    fi

    local routing_file="${ROUTING_DIR}/${app_id}.yml"

    if [ ! -f "${routing_file}" ]; then
        log "No routing config for ${app_id} at ${routing_file}, skipping"
        exit 0
    fi

    # Ensure output directories exist
    mkdir -p "${OUTPUT_DIR}"
    mkdir -p "${MIDDLEWARE_DIR}"

    log "Configuring routing for ${app_id} (HALOS_DOMAIN=${HALOS_DOMAIN})"
    generate_override "${routing_file}"
}

main "$@"
