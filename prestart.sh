#!/bin/bash
# Unified prestart script for halos-core-containers
# Initializes Traefik, Authelia, and Homarr in the correct order
set -e

# ============================================
# Common Setup
# ============================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PACKAGE_NAME="$(basename "$SCRIPT_DIR")"
ETC_DIR="/etc/container-apps/${PACKAGE_NAME}"
RUN_DIR="/run/container-apps/${PACKAGE_NAME}"
RUNTIME_ENV="${RUN_DIR}/runtime.env"

# Load config values from env files
set -a
[ -f "${ETC_DIR}/env.defaults" ] && . "${ETC_DIR}/env.defaults"
[ -f "${ETC_DIR}/env" ] && . "${ETC_DIR}/env"
set +a

# Create runtime directory
mkdir -p "${RUN_DIR}"

# Auto-detect domain from hostname (matches mDNS publisher)
HOSTNAME_SHORT=$(hostname -s 2>/dev/null || hostname | cut -d. -f1)
HALOS_DOMAIN="${HOSTNAME_SHORT}.local"

# Write common runtime environment
cat > "${RUNTIME_ENV}" << EOF
HALOS_DOMAIN=${HALOS_DOMAIN}
HOSTNAME=${HOSTNAME_SHORT}
EOF

echo "HaLOS Core Containers prestart"
echo "Domain: ${HALOS_DOMAIN}"

# Data directories for each service
TRAEFIK_DATA="${CONTAINER_DATA_ROOT}/traefik"
AUTHELIA_DATA="${CONTAINER_DATA_ROOT}/authelia"
HOMARR_DATA="${CONTAINER_DATA_ROOT}/homarr"

mkdir -p "${TRAEFIK_DATA}" "${AUTHELIA_DATA}" "${HOMARR_DATA}"

# ============================================
# Traefik Setup
# ============================================
echo ""
echo "=== Traefik Setup ==="

# Create acme.json with proper permissions if it doesn't exist
ACME_FILE="${TRAEFIK_DATA}/acme.json"
if [ ! -f "${ACME_FILE}" ]; then
    touch "${ACME_FILE}"
    chmod 600 "${ACME_FILE}"
    echo "Created acme.json"
fi

# Self-Signed TLS Certificate Generation
CERTS_DIR="${TRAEFIK_DATA}/certs"
CERT_FILE="${CERTS_DIR}/halos.crt"
KEY_FILE="${CERTS_DIR}/halos.key"
DOMAIN_FILE="${CERTS_DIR}/.domain"

mkdir -p "${CERTS_DIR}"

# Check if certificate needs to be (re)generated
NEED_CERT=false
if [ ! -f "${CERT_FILE}" ] || [ ! -f "${KEY_FILE}" ]; then
    echo "Certificate files not found, generating..."
    NEED_CERT=true
elif [ -f "${DOMAIN_FILE}" ]; then
    STORED_DOMAIN=$(cat "${DOMAIN_FILE}")
    if [ "${STORED_DOMAIN}" != "${HALOS_DOMAIN}" ]; then
        echo "Domain changed from ${STORED_DOMAIN} to ${HALOS_DOMAIN}, regenerating certificate..."
        NEED_CERT=true
    fi
else
    echo "Domain tracking file not found, regenerating certificate..."
    NEED_CERT=true
fi

if [ "${NEED_CERT}" = true ]; then
    echo "Generating self-signed TLS certificate for ${HALOS_DOMAIN}..."
    openssl req -x509 -nodes -days 3650 -newkey rsa:2048 \
        -keyout "${KEY_FILE}" \
        -out "${CERT_FILE}" \
        -subj "/CN=${HALOS_DOMAIN}" \
        -addext "subjectAltName=DNS:${HALOS_DOMAIN},DNS:*.${HALOS_DOMAIN}"
    chmod 600 "${KEY_FILE}"
    chmod 644 "${CERT_FILE}"
    echo "${HALOS_DOMAIN}" > "${DOMAIN_FILE}"
    echo "Certificate generated successfully"
else
    echo "Using existing certificate for ${HALOS_DOMAIN}"
fi

# Dynamic Configuration Directory
DYNAMIC_DIR="/etc/halos/traefik-dynamic.d"
DYNAMIC_SRC_DIR="${SCRIPT_DIR}/assets/traefik/dynamic"
mkdir -p "${DYNAMIC_DIR}"

# Generate dynamic TLS configuration
TLS_CONFIG_FILE="${DYNAMIC_DIR}/tls-default.yml"
cat > "${TLS_CONFIG_FILE}" << EOF
# Default TLS certificate configuration
# Auto-generated by halos-core-containers prestart
tls:
  stores:
    default:
      defaultCertificate:
        certFile: /certs/halos.crt
        keyFile: /certs/halos.key
EOF
chmod 644 "${TLS_CONFIG_FILE}"

# Generate Cockpit routing configuration
COCKPIT_CONFIG_FILE="${DYNAMIC_DIR}/cockpit.yml"
cat > "${COCKPIT_CONFIG_FILE}" << EOF
# Cockpit routing configuration
# Auto-generated by halos-core-containers prestart
http:
  routers:
    cockpit:
      rule: "Host(\`cockpit.${HALOS_DOMAIN}\`)"
      entrypoints:
        - web
      middlewares:
        - redirect-to-https
      service: cockpit
    cockpit-secure:
      rule: "Host(\`cockpit.${HALOS_DOMAIN}\`)"
      entrypoints:
        - websecure
      tls: {}
      service: cockpit
  services:
    cockpit:
      loadBalancer:
        serversTransport: cockpit-transport
        servers:
          - url: "https://host.docker.internal:9090"
  serversTransports:
    cockpit-transport:
      insecureSkipVerify: true
EOF
chmod 644 "${COCKPIT_CONFIG_FILE}"

# NOTE: Authelia routing is done via Docker labels in docker-compose.yml
# The halos.subdomain=auth label triggers mDNS publishing by halos-mdns-publisher

# Install dynamic config files from package
if [ -d "${DYNAMIC_SRC_DIR}" ]; then
    for src_file in "${DYNAMIC_SRC_DIR}"/*.yml; do
        if [ -f "${src_file}" ]; then
            filename=$(basename "${src_file}")
            dest_file="${DYNAMIC_DIR}/${filename}"
            if [ ! -f "${dest_file}" ]; then
                echo "Installing dynamic config: ${filename}"
                cp "${src_file}" "${dest_file}"
                chmod 644 "${dest_file}"
            fi
        fi
    done
fi

# Localhost redirect configuration
# Redirects http(s)://localhost and http(s)://*.localhost to https://${HALOS_DOMAIN}
LOCALHOST_REDIRECT_FILE="${DYNAMIC_DIR}/localhost-redirect.yml"
cat > "${LOCALHOST_REDIRECT_FILE}" << EOF
# Localhost to mDNS redirect
# Auto-generated by halos-core-containers prestart
http:
  routers:
    # Plain localhost HTTP -> https://${HALOS_DOMAIN}
    localhost-root-http:
      rule: "Host(\`localhost\`)"
      entrypoints:
        - web
      middlewares:
        - localhost-root-to-mdns
      service: noop@internal
      priority: 1000

    # Plain localhost HTTPS -> https://${HALOS_DOMAIN}
    localhost-root-https:
      rule: "Host(\`localhost\`)"
      entrypoints:
        - websecure
      middlewares:
        - localhost-root-to-mdns
      service: noop@internal
      priority: 1000
      tls: {}

    # Subdomain.localhost HTTP -> https://subdomain.${HALOS_DOMAIN}
    localhost-subdomain-http:
      rule: "HostRegexp(\`^.+\\\\.localhost\$\`)"
      entrypoints:
        - web
      middlewares:
        - localhost-subdomain-to-mdns
      service: noop@internal
      priority: 999

    # Subdomain.localhost HTTPS -> https://subdomain.${HALOS_DOMAIN}
    localhost-subdomain-https:
      rule: "HostRegexp(\`^.+\\\\.localhost\$\`)"
      entrypoints:
        - websecure
      middlewares:
        - localhost-subdomain-to-mdns
      service: noop@internal
      priority: 999
      tls: {}

  middlewares:
    localhost-root-to-mdns:
      redirectRegex:
        regex: "^https?://localhost(.*)"
        replacement: "https://${HALOS_DOMAIN}\${1}"
        permanent: false

    localhost-subdomain-to-mdns:
      redirectRegex:
        regex: "^https?://([^.]+)\\\\.localhost(.*)"
        replacement: "https://\${1}.${HALOS_DOMAIN}\${2}"
        permanent: false
EOF
chmod 644 "${LOCALHOST_REDIRECT_FILE}"

echo "Traefik setup complete"

# ============================================
# Homarr OIDC Client Setup (before Authelia merge)
# ============================================
echo ""
echo "=== Homarr OIDC Setup ==="

OIDC_CLIENTS_DIR="/etc/halos/oidc-clients.d"
OIDC_SECRET_FILE="${HOMARR_DATA}/oidc-secret"
OIDC_SNIPPET_SRC="${SCRIPT_DIR}/assets/homarr/oidc-client.yml"
OIDC_SNIPPET_DST="${OIDC_CLIENTS_DIR}/homarr.yml"

mkdir -p "${OIDC_CLIENTS_DIR}"

# Generate OIDC client secret if it doesn't exist
if [ ! -f "${OIDC_SECRET_FILE}" ]; then
    echo "Generating OIDC client secret..."
    openssl rand -hex 32 > "${OIDC_SECRET_FILE}"
    chmod 600 "${OIDC_SECRET_FILE}"
fi
OIDC_CLIENT_SECRET=$(cat "${OIDC_SECRET_FILE}")

# Install OIDC client snippet
if [ -f "${OIDC_SNIPPET_SRC}" ]; then
    echo "Installing OIDC client snippet to ${OIDC_SNIPPET_DST}"
    cp "${OIDC_SNIPPET_SRC}" "${OIDC_SNIPPET_DST}"
    chmod 644 "${OIDC_SNIPPET_DST}"
fi

# Configure Homarr SSO environment
ENV_FILE="${ETC_DIR}/env"

# Generate SECRET_ENCRYPTION_KEY if not set
if [ -z "$SECRET_ENCRYPTION_KEY" ]; then
    echo "Generating SECRET_ENCRYPTION_KEY..."
    SECRET_ENCRYPTION_KEY=$(openssl rand -hex 32)
    echo "SECRET_ENCRYPTION_KEY=\"${SECRET_ENCRYPTION_KEY}\"" >> "${ENV_FILE}"
fi

# Generate AUTH_SECRET for NextAuth.js
if ! grep -qE "^AUTH_SECRET=\"[^\"]+\"" "${ENV_FILE}" 2>/dev/null; then
    echo "Generating AUTH_SECRET..."
    AUTH_SECRET=$(openssl rand -hex 32)
    echo "AUTH_SECRET=\"${AUTH_SECRET}\"" >> "${ENV_FILE}"
fi

# Set OIDC configuration for Homarr
declare -A HOMARR_SSO_CONFIG=(
    ["AUTH_PROVIDERS"]="oidc"
    ["AUTH_OIDC_ISSUER"]="https://auth.${HALOS_DOMAIN}"
    ["AUTH_OIDC_CLIENT_ID"]="homarr"
    ["AUTH_OIDC_CLIENT_SECRET"]="${OIDC_CLIENT_SECRET}"
    ["AUTH_OIDC_CLIENT_NAME"]="HaLOS"
    ["AUTH_OIDC_SCOPE_OVERWRITE"]="openid profile email groups"
    ["AUTH_LOGOUT_REDIRECT_URL"]="https://auth.${HALOS_DOMAIN}/logout"
    ["AUTH_OIDC_FORCE_USERINFO"]="true"
    ["AUTH_OIDC_ENABLE_DANGEROUS_ACCOUNT_LINKING"]="true"
)

for key in "${!HOMARR_SSO_CONFIG[@]}"; do
    if ! grep -q "^${key}=" "${ENV_FILE}" 2>/dev/null; then
        echo "${key}=\"${HOMARR_SSO_CONFIG[$key]}\"" >> "${ENV_FILE}"
    elif [ "${key}" = "AUTH_OIDC_CLIENT_SECRET" ]; then
        # Always update client secret to match oidc-secret file
        sed -i "s|^AUTH_OIDC_CLIENT_SECRET=.*|AUTH_OIDC_CLIENT_SECRET=\"${OIDC_CLIENT_SECRET}\"|" "${ENV_FILE}"
    fi
done

echo "Homarr OIDC setup complete"

# ============================================
# Authelia Setup
# ============================================
echo ""
echo "=== Authelia Setup ==="

AUTHELIA_SECRETS_FILE="${AUTHELIA_DATA}/secrets.env"
AUTHELIA_CONFIG_FILE="${AUTHELIA_DATA}/configuration.yml"
AUTHELIA_OIDC_FILE="${AUTHELIA_DATA}/oidc-clients.yml"
AUTHELIA_TEMPLATE="${SCRIPT_DIR}/assets/authelia/configuration.yml.template"

# Generate Authelia secrets on first boot
if [ ! -f "${AUTHELIA_SECRETS_FILE}" ]; then
    echo "Generating Authelia secrets..."
    SESSION_SECRET=$(openssl rand -hex 32)
    OIDC_HMAC_SECRET=$(openssl rand -hex 32)
    STORAGE_ENCRYPTION_KEY=$(openssl rand -hex 32)
    RESET_PASSWORD_JWT_SECRET=$(openssl rand -hex 32)
    OIDC_PRIVATE_KEY=$(openssl genrsa 4096 2>/dev/null)

    cat > "${AUTHELIA_SECRETS_FILE}" << EOF
SESSION_SECRET="${SESSION_SECRET}"
OIDC_HMAC_SECRET="${OIDC_HMAC_SECRET}"
STORAGE_ENCRYPTION_KEY="${STORAGE_ENCRYPTION_KEY}"
RESET_PASSWORD_JWT_SECRET="${RESET_PASSWORD_JWT_SECRET}"
EOF
    echo "${OIDC_PRIVATE_KEY}" > "${AUTHELIA_DATA}/oidc_private_key.pem"
    chmod 600 "${AUTHELIA_SECRETS_FILE}" "${AUTHELIA_DATA}/oidc_private_key.pem"
    echo "Authelia secrets generated"
fi

# Load secrets
. "${AUTHELIA_SECRETS_FILE}"
OIDC_PRIVATE_KEY=$(cat "${AUTHELIA_DATA}/oidc_private_key.pem")

# Hash a plaintext secret using Authelia's CLI
hash_client_secret() {
    local plaintext="$1"
    local hash_output
    hash_output=$(docker run --rm authelia/authelia:4.39 authelia crypto hash generate pbkdf2 \
        --variant sha512 \
        --password "${plaintext}" 2>/dev/null)
    if [ $? -ne 0 ]; then
        return 1
    fi
    echo "$hash_output" | grep 'Digest:' | sed 's/Digest: //'
}

# Merge OIDC client snippets from .d directory
merge_oidc_clients() {
    echo "Merging OIDC client snippets..."
    local client_count=0
    local clients_yaml=""

    for snippet in "${OIDC_CLIENTS_DIR}"/*.yml; do
        [ -e "$snippet" ] || continue
        local snippet_name=$(basename "$snippet")
        echo "  Processing: ${snippet_name}"

        # Read fields from snippet
        local client_id=$(grep -E '^client_id:' "$snippet" | sed 's/client_id:[[:space:]]*//' | tr -d "'\"")
        local client_name=$(grep -E '^client_name:' "$snippet" | sed 's/client_name:[[:space:]]*//' | tr -d "'\"")
        local client_secret_file=$(grep -E '^client_secret_file:' "$snippet" | sed 's/client_secret_file:[[:space:]]*//' | tr -d "'\"")
        local consent_mode=$(grep -E '^consent_mode:' "$snippet" | sed 's/consent_mode:[[:space:]]*//' | tr -d "'\"")
        local token_auth_method=$(grep -E '^token_endpoint_auth_method:' "$snippet" | sed 's/token_endpoint_auth_method:[[:space:]]*//' | tr -d "'\"")

        [ -z "$client_id" ] && { echo "  WARNING: Skipping ${snippet_name} - missing client_id"; continue; }

        # Read and hash client secret
        local client_secret_hash=""
        if [ -n "$client_secret_file" ] && [ -f "$client_secret_file" ]; then
            local plaintext_secret=$(cat "$client_secret_file")
            if ! client_secret_hash=$(hash_client_secret "$plaintext_secret"); then
                echo "  ERROR: Failed to hash client secret for ${snippet_name}"
                continue
            fi
        else
            echo "  WARNING: Skipping ${snippet_name} - client_secret_file not found: ${client_secret_file}"
            continue
        fi

        # Extract redirect_uris
        local redirect_uris=""
        local in_redirect=false
        while IFS= read -r line; do
            if echo "$line" | grep -qE '^redirect_uris:'; then
                in_redirect=true
                continue
            fi
            if $in_redirect; then
                if echo "$line" | grep -qE '^[[:space:]]+-'; then
                    local uri=$(echo "$line" | sed "s/^[[:space:]]*-[[:space:]]*//" | tr -d "'\"")
                    uri="${uri//\$\{HALOS_DOMAIN\}/${HALOS_DOMAIN}}"
                    redirect_uris="${redirect_uris}          - '${uri}'\n"
                elif echo "$line" | grep -qE '^[a-z_]+:'; then
                    break
                fi
            fi
        done < "$snippet"

        # Extract scopes
        local scopes_line=$(grep -E '^scopes:' "$snippet")
        local scopes=""
        if echo "$scopes_line" | grep -qE '\[.*\]'; then
            scopes=$(echo "$scopes_line" | sed 's/scopes:[[:space:]]*//')
        else
            scopes="[openid, profile, email]"
        fi

        # Build client YAML
        clients_yaml="${clients_yaml}      - client_id: ${client_id}
        client_name: '${client_name:-${client_id}}'
        client_secret: '${client_secret_hash}'
        public: false
        authorization_policy: one_factor
        redirect_uris:
$(echo -e "${redirect_uris}" | sed '/^$/d')
        scopes: ${scopes}
        consent_mode: ${consent_mode:-implicit}
        token_endpoint_auth_method: ${token_auth_method:-client_secret_post}
"
        client_count=$((client_count + 1))
    done

    if [ $client_count -eq 0 ]; then
        echo "  No OIDC client snippets found - OIDC will be disabled"
        cat > "${AUTHELIA_OIDC_FILE}" << 'EOF'
# Authelia OIDC Configuration - No clients configured
EOF
    else
        echo "  Merged ${client_count} OIDC client(s)"
        local indented_key
        indented_key=$(echo "${OIDC_PRIVATE_KEY}" | awk 'NR==1 {print} NR>1 {print "          " $0}')

        cat > "${AUTHELIA_OIDC_FILE}" << EOF
# Authelia OIDC Configuration
# Auto-generated by halos-core-containers prestart
identity_providers:
  oidc:
    hmac_secret: '${OIDC_HMAC_SECRET}'
    jwks:
      - key: |
          ${indented_key}
    clients:
${clients_yaml}
EOF
    fi
    chmod 600 "${AUTHELIA_OIDC_FILE}"
}

# Process Authelia configuration template
process_authelia_template() {
    echo "Processing Authelia configuration template..."
    local template
    template=$(cat "${AUTHELIA_TEMPLATE}")

    local indented_key
    indented_key=$(echo "${OIDC_PRIVATE_KEY}" | awk 'NR==1 {print} NR>1 {print "          " $0}')

    template="${template//\$\{SESSION_SECRET\}/${SESSION_SECRET}}"
    template="${template//\$\{OIDC_HMAC_SECRET\}/${OIDC_HMAC_SECRET}}"
    template="${template//\$\{STORAGE_ENCRYPTION_KEY\}/${STORAGE_ENCRYPTION_KEY}}"
    template="${template//\$\{RESET_PASSWORD_JWT_SECRET\}/${RESET_PASSWORD_JWT_SECRET}}"
    template="${template//\$\{HALOS_DOMAIN\}/${HALOS_DOMAIN}}"

    echo "${template}" | awk -v key="${indented_key}" '
        /\$\{OIDC_PRIVATE_KEY\}/ { sub(/\$\{OIDC_PRIVATE_KEY\}/, key) }
        { print }
    ' > "${AUTHELIA_CONFIG_FILE}"

    chmod 600 "${AUTHELIA_CONFIG_FILE}"
    echo "Authelia configuration generated"
}

process_authelia_template
merge_oidc_clients

# Create initial admin user if not exists
if [ ! -f "${AUTHELIA_DATA}/users_database.yml" ]; then
    echo "Creating initial admin user..."
    DEFAULT_PASSWORD="halos"
    INITIAL_HASH=$(docker run --rm authelia/authelia:4.39 authelia crypto hash generate argon2 \
        --password "${DEFAULT_PASSWORD}" 2>/dev/null | grep 'Digest:' | sed 's/Digest: //')

    if [ -z "${INITIAL_HASH}" ]; then
        echo "ERROR: Failed to generate password hash"
        exit 1
    fi

    cat > "${AUTHELIA_DATA}/users_database.yml" << EOF
# Authelia Users Database
# Default admin password is "halos" - please change after first login
users:
  admin:
    displayname: "Administrator"
    email: admin@${HALOS_DOMAIN}
    password: "${INITIAL_HASH}"
    groups:
      - admins
EOF
    chmod 600 "${AUTHELIA_DATA}/users_database.yml"
    echo "Created admin user with default password 'halos'"
fi

echo "Authelia setup complete"

# ============================================
# Homarr Database Initialization
# ============================================
echo ""
echo "=== Homarr Database Setup ==="

SEED_DB="/var/lib/halos-homarr-branding/db-seed.sqlite3"
HOMARR_DB="${HOMARR_DATA}/data/db/db.sqlite"

if [ ! -f "$HOMARR_DB" ] && [ -f "$SEED_DB" ]; then
    echo "Initializing Homarr database from seed..."
    mkdir -p "$(dirname "$HOMARR_DB")"
    cp "$SEED_DB" "$HOMARR_DB"
    chmod 644 "$HOMARR_DB"
    echo "Homarr database initialized"
else
    echo "Homarr database already exists or no seed available"
fi

echo ""
echo "=== HaLOS Core Containers prestart complete ==="
