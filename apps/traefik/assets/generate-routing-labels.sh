#!/bin/bash
# Generate Traefik Docker labels from generic routing declarations
# This script reads /etc/halos/routing.d/*.yml and generates:
# 1. Docker-compose override files in /run/halos/routing-labels/
# 2. Per-app ForwardAuth middleware in /etc/halos/traefik-dynamic.d/
#
# Called by Traefik prestart.sh before the container starts.

set -e

# Directories can be overridden via environment variables for testing
ROUTING_DIR="${ROUTING_DIR:-/etc/halos/routing.d}"
OUTPUT_DIR="${OUTPUT_DIR:-/run/halos/routing-labels}"
MIDDLEWARE_DIR="${MIDDLEWARE_DIR:-/etc/halos/traefik-dynamic.d}"

# Ensure output directories exist
mkdir -p "${OUTPUT_DIR}"
mkdir -p "${MIDDLEWARE_DIR}"

# Get HALOS_DOMAIN from environment or derive from hostname
if [ -z "${HALOS_DOMAIN}" ]; then
    HOSTNAME="$(hostname -s)"
    HALOS_DOMAIN="${HOSTNAME}.local"
fi

log() {
    echo "[generate-routing-labels] $1"
}

# Parse YAML value - simple grep-based parser for our known format
# Usage: yaml_get "key" < file.yml
yaml_get() {
    local key="$1"
    grep "^${key}:" | sed "s/^${key}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//'
}

# Parse nested YAML value
# Usage: yaml_get_nested "parent" "child" < file.yml
yaml_get_nested() {
    local parent="$1"
    local child="$2"
    sed -n "/^${parent}:/,/^[a-z]/p" | grep "^  ${child}:" | sed "s/^  ${child}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//'
}

# Parse deeply nested YAML value (3 levels)
# Usage: yaml_get_deep "parent" "child" "grandchild" < file.yml
yaml_get_deep() {
    local parent="$1"
    local child="$2"
    local grandchild="$3"
    sed -n "/^${parent}:/,/^[a-z]/p" | sed -n "/^  ${child}:/,/^  [a-z]/p" | grep "^    ${grandchild}:" | sed "s/^    ${grandchild}:[[:space:]]*//" | sed 's/^"//' | sed 's/"$//'
}

# Check if a routing file has custom forward auth headers
has_custom_headers() {
    local file="$1"
    # Check for headers under auth.forward_auth.headers
    # Headers are indented with 8 spaces (under headers: which is under forward_auth:)
    grep -q "forward_auth:" "$file" 2>/dev/null && \
        grep -q "headers:" "$file" 2>/dev/null && \
        grep -qE "^[[:space:]]{6,}[A-Za-z]" "$file" 2>/dev/null
}

# Extract custom headers as key=value pairs
# Returns lines like: Remote-User=X-WEBAUTH-USER
get_custom_headers() {
    local file="$1"
    # Extract lines under headers: that look like "key: value"
    # These are indented with 6+ spaces
    sed -n '/^auth:/,/^[a-z]/p' "$file" | \
        sed -n '/forward_auth:/,/^  [a-z]/p' | \
        sed -n '/headers:/,/^    [a-z]/p' | \
        grep -E "^[[:space:]]{6,}[A-Za-z]" | \
        sed 's/^[[:space:]]*//' | \
        sed 's/:[[:space:]]*/=/'
}

# Generate per-app ForwardAuth middleware YAML
generate_middleware() {
    local app_id="$1"
    local routing_file="$2"
    local middleware_file="${MIDDLEWARE_DIR}/authelia-${app_id}.yml"

    log "Generating middleware for ${app_id}"

    # Get custom headers
    local headers=""
    while IFS='=' read -r authelia_header app_header; do
        if [ -n "${authelia_header}" ]; then
            headers="${headers}
          - ${authelia_header}"
        fi
    done < <(get_custom_headers "$routing_file")

    cat > "${middleware_file}" << EOF
# Per-app ForwardAuth middleware for ${app_id}
# Auto-generated by generate-routing-labels.sh
# Custom header mappings from routing.yml

http:
  middlewares:
    authelia-${app_id}:
      forwardAuth:
        address: "http://authelia:9091/api/authz/forward-auth"
        trustForwardHeader: true
        authResponseHeaders:${headers}
EOF

    chmod 644 "${middleware_file}"
    log "Created middleware: ${middleware_file}"
}

# Generate docker-compose override with Traefik labels
generate_override() {
    local routing_file="$1"

    # Parse routing.yml
    local app_id
    local service_name
    local subdomain
    local port
    local backend_type
    local auth_mode

    app_id=$(yaml_get "app_id" < "$routing_file")
    service_name=$(yaml_get_deep "routing" "backend" "service" < "$routing_file")
    port=$(yaml_get_deep "routing" "backend" "port" < "$routing_file")
    backend_type=$(yaml_get_deep "routing" "backend" "type" < "$routing_file")
    auth_mode=$(yaml_get_nested "auth" "mode" < "$routing_file")

    # Handle subdomain specially: empty string ("") is valid (means root domain)
    # Only default to app_id if subdomain key is not present at all
    if grep -q "^  subdomain:" "$routing_file"; then
        subdomain=$(yaml_get_nested "routing" "subdomain" < "$routing_file")
    else
        subdomain="${app_id}"
    fi

    # Validate required fields
    if [ -z "${app_id}" ]; then
        log "ERROR: Missing app_id in ${routing_file}"
        return 1
    fi

    if [ -z "${service_name}" ]; then
        log "ERROR: Missing routing.backend.service in ${routing_file}"
        return 1
    fi

    if [ -z "${port}" ]; then
        log "ERROR: Missing routing.backend.port in ${routing_file}"
        return 1
    fi

    # Default values for optional fields
    [ -z "${backend_type}" ] && backend_type="container"
    [ -z "${auth_mode}" ] && auth_mode="forward_auth"

    log "Processing ${app_id}: subdomain=${subdomain}, port=${port}, auth=${auth_mode}"

    # Build host rule
    local host_rule
    if [ -z "${subdomain}" ] || [ "${subdomain}" = '""' ]; then
        # Empty subdomain = root domain
        host_rule="Host(\`\${HALOS_DOMAIN}\`)"
    else
        host_rule="Host(\`${subdomain}.\${HALOS_DOMAIN}\`)"
    fi

    # Determine middleware
    local middleware_label=""
    if [ "${auth_mode}" = "forward_auth" ]; then
        if has_custom_headers "$routing_file"; then
            # Generate per-app middleware
            generate_middleware "${app_id}" "$routing_file"
            middleware_label="      traefik.http.routers.${app_id}.middlewares: \"authelia-${app_id}@file\""
        else
            # Use default Authelia middleware
            middleware_label="      traefik.http.routers.${app_id}.middlewares: \"authelia@file\""
        fi
    fi
    # For OIDC and none auth modes, no middleware label is added

    # Determine backend configuration
    local backend_label
    if [ "${backend_type}" = "host" ]; then
        backend_label="      traefik.http.services.${app_id}.loadbalancer.server.url: \"http://host.docker.internal:${port}\""
    else
        backend_label="      traefik.http.services.${app_id}.loadbalancer.server.port: \"${port}\""
    fi

    # Build middleware labels for both routers
    local http_middleware_label=""
    local https_middleware_label=""
    if [ -n "${middleware_label}" ]; then
        # Replace the router name for each entrypoint
        http_middleware_label="${middleware_label}"
        https_middleware_label=$(echo "${middleware_label}" | sed "s/routers\.${app_id}\./routers.${app_id}-secure./")
    fi

    # Generate override file with separate HTTP and HTTPS routers
    local override_file="${OUTPUT_DIR}/${app_id}.yml"

    cat > "${override_file}" << EOF
# Docker-compose override with Traefik labels for ${app_id}
# Auto-generated by generate-routing-labels.sh
# Source: ${routing_file}

services:
  ${service_name}:
    labels:
      traefik.enable: "true"
      # HTTP router - redirects to HTTPS
      traefik.http.routers.${app_id}.rule: "${host_rule}"
      traefik.http.routers.${app_id}.entrypoints: "web"
      traefik.http.routers.${app_id}.middlewares: "redirect-to-https@file"
      # HTTPS router (websecure entrypoint with TLS)
      traefik.http.routers.${app_id}-secure.rule: "${host_rule}"
      traefik.http.routers.${app_id}-secure.entrypoints: "websecure"
      traefik.http.routers.${app_id}-secure.tls: "true"
${https_middleware_label}
      # Backend service
${backend_label}
      halos.subdomain: "${subdomain}"
EOF

    chmod 644 "${override_file}"
    log "Created override: ${override_file}"
}

# Main: Process all routing files
main() {
    log "Starting routing label generation"
    log "HALOS_DOMAIN=${HALOS_DOMAIN}"

    if [ ! -d "${ROUTING_DIR}" ]; then
        log "Routing directory does not exist: ${ROUTING_DIR}"
        log "No routing files to process"
        return 0
    fi

    local count=0
    for routing_file in "${ROUTING_DIR}"/*.yml; do
        if [ -f "${routing_file}" ]; then
            generate_override "${routing_file}" && ((count++)) || true
        fi
    done

    log "Processed ${count} routing file(s)"
}

main "$@"
